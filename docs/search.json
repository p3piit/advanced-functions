[
  {
    "objectID": "tutorials/user_fun/more.html",
    "href": "tutorials/user_fun/more.html",
    "title": "Second Topic",
    "section": "",
    "text": "Multiple Arguments and Default Values\nFunctions can take several arguments, and some may have default values, so the user can choose whether to specify them.\n\npower &lt;- function(x, exp = 2) {\n  x ^ exp\n}\n\npower(3)\n\n[1] 9\n\npower(3, 3)\n\n[1] 27\n\n\nHere, if you don’t specify exp, it defaults to 2 (squaring).\nYou can also include if statements inside your functions to make them react to different inputs.\n\ncategorize_age &lt;- function(age) {\n  if (age &lt; 18) {\n    \"minor\"\n  } else {\n    \"adult\"\n  }\n}\n\ncategorize_age(17)\n\n[1] \"minor\"\n\n\nThis is a simple but powerful idea: you can make your functions decide what to do based on input values.\nA function can return any R object — a vector, list, data frame, or even a plot. For example:\n\nsummarize_vector &lt;- function(vec) {\n  mean_val &lt;- mean(vec, na.rm = TRUE)\n  sd_val &lt;- sd(vec, na.rm = TRUE)\n  n &lt;- sum(!is.na(vec))\n  \n  return(list(mean = mean_val, sd = sd_val, n = n))\n}\n\n\nsummarize_vector(c(1, 2, 3, 4, NA))\n\n$mean\n[1] 2.5\n\n$sd\n[1] 1.290994\n\n$n\n[1] 4\n\n\nWhen you create a function, R also creates a new environment for it to run in. Variables defined inside a function exist only within that function — they are not available outside it.\n\nadd_one &lt;- function(x) {\n  y &lt;- x + 1\n  return(y)\n}\n\nadd_one(4)\n\n[1] 5\n\ny\n\nError: object 'y' not found\n\n\nHere, y exists only while the function runs; after it returns, y disappears. This isolation prevents unintended side effects.\nFunctions can access variables defined in the global environment, but they will not modify them unless you explicitly return a value and reassign it.\nx &lt;- 10 increment &lt;- function() { x + 1 } increment() #&gt; [1] 11 x #&gt; [1] 10 # unchanged\nThis separation of environments is one of R’s core design principles: functions are self-contained and safe to reuse without altering your workspace.\nAnonymous Functions and Shortcuts\nSometimes you need a quick, one-off function — for example, as an argument to another function — without giving it a name. These are called anonymous functions.\nYou can define them inline with the usual function() syntax:\nsapply(1:5, function(x) x^2) #&gt; [1] 1 4 9 16 25\nSince R 4.1, there’s an even shorter syntax using ( ):\nsapply(1:5, (x) x^2)\nAnonymous functions are especially handy inside tidyverse pipelines:\nbfi |&gt; mutate(age_sq = sapply(age, (x) x^2))\nThey let you write small transformations on the fly without cluttering your workspace with new function names.\n\n\n\n Back to top",
    "crumbs": [
      "Open-Stat-Prog",
      "User Defined Functions",
      "Second Topic"
    ]
  },
  {
    "objectID": "tutorials/user_fun/index.html",
    "href": "tutorials/user_fun/index.html",
    "title": "User defined Functions",
    "section": "",
    "text": "In R, functions are the fundamental building blocks of the language. Every command you call—whether it’s mean(), summary(), or mutate()—is a function. Learning to define your own functions allows you to capture repeated operations, reduce code duplication, and give structure to your analyses.\nWhen your analysis grows, you will often find yourself performing the same calculation or transformation on different datasets or variables. Instead of rewriting the same code each time, you can wrap that logic inside a function. This not only makes your code shorter and clearer, but also easier to debug, reuse, and share.\n\n\n\n Back to top",
    "crumbs": [
      "Open-Stat-Prog",
      "User Defined Functions"
    ]
  }
]