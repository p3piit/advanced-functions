---
title: "More on User Defined Functions"
---

### Multiple Arguments and Default Values

Functions can take several arguments, and some may have default values, so the user can choose whether to specify them.

```{r}
power <- function(x, exp = 2) {
  x ^ exp
}

power(3)

power(3, 3)
```

Here, if you don’t specify exp, it defaults to 2 (squaring).


You can also include `if` statements inside your functions to make them react to different inputs.

```{r}
categorize_age <- function(age) {
  if (age < 18) {
    "minor"
  } else {
    "adult"
  }
}

categorize_age(17)
```

This is a simple but powerful idea: you can make your functions decide what to do based on input values.

A function can return any R object — a vector, list, data frame, or even a plot. For example:

```{r}
summarize_vector <- function(vec) {
  mean_val <- mean(vec, na.rm = TRUE)
  sd_val <- sd(vec, na.rm = TRUE)
  n <- sum(!is.na(vec))
  
  return(list(mean = mean_val, sd = sd_val, n = n))
}


summarize_vector(c(1, 2, 3, 4, NA))
```

When you create a function, R also creates a new environment for it to run in. Variables defined inside a function exist only within that function — they are not available outside it.

```{r, error=TRUE}
add_one <- function(x) {
  y <- x + 1
  return(y)
}

add_one(4)

y
```

Here, `y` exists only while the function runs; after it returns, `y` disappears. This isolation prevents unintended side effects.

Functions can access variables defined in the global environment, but they will not modify them unless you explicitly return a value and reassign it.

```{r}

x <- 10
increment <- function() {
  x + 1
}
increment()

x
```

This separation of environments is one of R’s core design principles: functions are self-contained and safe to reuse without altering your workspace.

### Anonymous Functions and Shortcuts

Sometimes you need a quick, one-off function — for example, as an argument to another function — without giving it a name. These are called anonymous functions.

You can define them inline with the usual `function()` syntax:

```{r}
sapply(1:5, function(x) x^2)
```

Anonymous functions are especially handy inside tidyverse pipelines:

```{r}
library(dplyr)
data <- data.frame(age = c(20, 25, 30, 35, 40),
                   weight = c(150, 160, 170, 180, 190),
                   height = c(65, 66, 67, 68, 69))
data|> mutate(age_sq = sapply(age, function(x) x^2))
```

They let you write small transformations on the fly without cluttering your workspace with new function names.

::: practice

## Practice

a. Write a function called that takes a single numeric argument and returns a character string describing whether the number is `"positive"`, `"negative"`, or `"zero"`. 

b. Add a second argument to your function that allows the user to specify whether they want the output in uppercase or lowercase letters. The default should be lowercase.

:::: {.panel-tabset}
## {{< var tab_title.editor >}}

```{webr-r}

```

## {{< var tab_title.hint >}}

To go from lowercase to uppercase, you can use the `toupper()` function in R.

## {{< var tab_title.solution >}}

```{r}
# a 
describe_number <- function(num) {
  if (num > 0) {
    return("positive")
  } else if (num < 0) {
    return("negative")
  } else {
    return("zero")
  }
}

# b
describe_number <- function(num, to_upper = FALSE) {
  if (num > 0) {
    result <- "positive"
  } else if (num < 0) {
    result <- "negative"
  } else {
    result <- "zero"
  }
  if (to_upper) {
    result <- toupper(result)
  }
  return(result)
}
```
::::

:::


